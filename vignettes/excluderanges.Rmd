---
title: "Introduction to excluderanges"
author: 
  - name: Mikhail Dozmorov & Jonathan Ogata
    affiliation:
    - Virginia Commonwealth University
    email: mikhail.dozmorov@gmail.com
output: 
  BiocStyle::html_document:
    self_contained: yes
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{excluderanges}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(BiocStyle)
```

# Exclude ranges

Genomic ranges of problematic genomic regions that should be avoided when 
working with genomic data. For human, mouse, and selected model organisms.

<!-- badges: start
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
badges: end -->
 
TL;DR - For human hg38 genome assembly, [Anshul](https://twitter.com/anshulkundaje) [recommends](https://twitter.com/anshulkundaje/status/1263546023151992832?s=20) 
[ENCFF356LFX exclusion list regions](https://www.encodeproject.org/files/ENCFF356LFX/).  

BED files of exclusion regions are available on the [ENCODE project](https://www.encodeproject.org/search/?searchTerm=exclusion+list)
website [@Amemiya:2019aa] and throughout [Github](https://github.com). *Homo sapien* (hg19, hg38, and T2T (presented here) ), *Mus musculus* (mm9, mm10), *Caenorhabditis elegans* (ce10, ce11), *Drosophila melanogaster* (dm3, dm6), *Arabidopsis thaliana* (TAIR10), and *Danio rerio* (danRer10) exclusion regions are available.
However, exclusion lists generated by multiple labs using different methods produce a variety of results. With so many choices and such variety, choosing an excludable set is an open question. The purpose of this package is to provide a unified place for informed retrieval of excludable regions.

Naming convention: `<genome assembly>.<lab>.<original file name>`, e.g.,
`hg19.Birney.wgEncodeDacMapabilityConsensusExcludable`.

See [make-data.R](inst/scripts/make-data.R) how to create the excluderanges 
GRanges objects.

## Install `excluderanges`

```{r "install", eval = FALSE}
if (!requireNamespace("BiocManager", quietly = TRUE)) {
    install.packages("BiocManager")
}
# Install the development version of Bioconductor (need 3.14 and above)
# BiocManager::install(version = "devel")
# Check that you have a valid Bioconductor installation
# BiocManager::valid()
# Install the package
BiocManager::install("excluderanges", version = "devel")

# BiocManager::install("mdozmorov/excluderanges")
```

## Use excluderanges

An overview of what's available:

```{r AnnotationHub}
suppressMessages(library(AnnotationHub))
ah <- AnnotationHub()
query_data <- query(ah, "excluderanges")
query_data
```


hg38 excluderanges coordinates recommended by Anshul:
<!-- Need to check if this is Kundaje unified, i.e. https://www.encodeproject.org/files/ENCFF356LFX/ -->

```{r hg38excluderanges}
# Check titles
# as.data.frame(mcols(query_data[1:10])["title"]) 
excludeGR.hg38.Kundaje.1 <- query_data[["AH95917"]]
excludeGR.hg38.Kundaje.1
```

Save the data in a BED file, if needed.

```{r eval=FALSE}
rtracklayer::export(excludeGR.hg38.Kundaje.1, "hg38.Kundaje.GRCh38_unified_Excludable.bed", format = "bed")
```


We can load other excludable regions for the hg38 genome assembly and compare them.
<!-- THIS LIST NEEDS TO BE UPDATED ONCE ALL SETS ARE ON ANNOTATION HUB -->
<!-- THIS LIST NEEDS TO BE UPDATED ONCE ALL SETS ARE ON ANNOTATION HUB -->
<!-- THIS LIST NEEDS TO BE UPDATED ONCE ALL SETS ARE ON ANNOTATION HUB -->
<!-- THIS LIST NEEDS TO BE UPDATED ONCE ALL SETS ARE ON ANNOTATION HUB -->

```{r allhg38excluderanges}
query_data <- query(ah, c("excluderanges", "hg38", "Exclusion regions"))
query_data
excludeGR.hg38.Bernstein <- query_data[["AH95915"]]
excludeGR.hg38.Kundaje.2 <- query_data[["AH95916"]]
excludeGR.hg38.Reddy     <- query_data[["AH95918"]]
excludeGR.hg38.Wold      <- query_data[["AH95919"]]
excludeGR.hg38.Yeo       <- query_data[["AH95920"]]

all_excludeGR_list <- list(
  excludeGR.hg38.Bernstein, 
  excludeGR.hg38.Kundaje.1, 
  excludeGR.hg38.Kundaje.2,
  excludeGR.hg38.Reddy,     
  excludeGR.hg38.Wold,      
  excludeGR.hg38.Yeo       
)

name_short <- c(
  "Berstein",
  "Kundaje.1",
  "Kundaje.2",
  "Reddy",
  "Wold",
  "Yeo"
)
```

Compare the total number of excludable regions.

```{r excluderanges_hg38_count, fig.width=6.5, fig.height=2}
library(ggplot2)


length_data<- data.frame(
  Set = name_short,
  Count = sapply(all_excludeGR_list, function(x) length(x))
)

length <- ggplot(length_data, aes(x = Count, y = reorder(Set, Count), fill = Set)) + 
  ylab("") +
  geom_bar(stat="identity") + 
  xlab('') +
  ggtitle("Number of Regions") +
  theme_bw() +
  theme(legend.position = "none")

length

# svg(file.path('man', 'figures', 'excluderanges_hg38_count.svg'), width = 5.5, height = 2)
# length
# dev.off()
```

```{r echo=FALSE, eval=F}
knitr::include_graphics('man/figures/excluderanges_hg38_count.svg')
```

Compare the log10(width) distributions of excludable regions.

```{r excluderanges_hg38_width, fig.width=6.5, fig.height=2}
library(ggridges)

# find the width distribution of each excludable set
Width = as.integer(
  unlist(
    lapply(all_excludeGR_list, function(x) as.integer(width(x)))
  )
)

# each distribution needs a name assigned to it
Source <- as.character(
  unlist(
    mapply(function(name, grange_object) rep(name, length(grange_object)), name_short, all_excludeGR_list)
  )
)

Median <- as.integer(
  unlist(
    lapply(all_excludeGR_list, function(set) rep( median(width(set)), length(set) ))
  )
)

# make width distribution dataframe
width_dist_data <- data.frame(Width, Source, Median)

# plot distribution of region widths
width_dist <- ggplot(width_dist_data, aes( x = log10(Width), y = reorder( Source, Median ), fill = Source )) +
  ggridges::geom_density_ridges() +
  labs( y = NULL,
        x = NULL,
        title = 'Width distribution (bp), log10(width)' ) +
  theme_bw() +
  theme(legend.position = 'none')

width_dist

# svg(file.path('man', 'figures', 'excluderanges_hg38_width.svg'), width = 5.5, height = 2)
# width_dist
# dev.off()
```

```{r echo=FALSE, eval=F}
knitr::include_graphics('man/figures/excluderanges_hg38_width.svg')
```

We can investigate the total width of each set of excludable ranges, log 10 scale.

```{r excluderanges_hg38_sumwidth, fig.width=6.5, fig.height=2}

width_data<- data.frame(
  Set = name_short,
  Count = sapply(all_excludeGR_list, function(x) sum(width(x)))
)

# find the total width of each excludable region
coverage <- ggplot(width_data, aes(x = Count, y = reorder(Set, Count), fill = Set)) + 
  labs(y = NULL,
       x = NULL,
       title = "Total Coverage, log10 scale") +
  geom_bar(stat="identity") +
  scale_x_log10()  +
  theme_bw() +
  theme(legend.position = "none")

coverage

# svg(file.path('man', 'figures', 'excluderanges_hg38_sumwidth.svg'), width = 5.5, height = 2)
# coverage
# dev.off()

```

```{r echo=FALSE, eval=F}
knitr::include_graphics('man/figures/excluderanges_hg38_sumwidth.svg')
```

We can compare Jaccard overlap between hg38 excludable sets. 

```{r excluderanges_hg38_jaccard, warning=FALSE, fig.width=6.5, fig.height=6}
library(pheatmap)
library(stringr)

# Jaccard calculations
jaccard <- function(gr_a, gr_b) {
  intersects <- GenomicRanges::intersect(gr_a, gr_b, ignore.strand = TRUE)
  intersection <- sum(width(intersects))
  union <- sum(width(GenomicRanges::union(gr_a, gr_b, ignore.strand = TRUE)))
  DataFrame(intersection, union, 
            jaccard = intersection/union,
             n_intersections = length(intersects))
}
# Correlation matrix, empty
mtx_to_plot <- matrix(data = 0, nrow = length(all_excludeGR_list), ncol = length(all_excludeGR_list))

suppressWarnings(
  # Fill it in
  for (i in 1:length(all_excludeGR_list)) {
    for (j in 1:length(all_excludeGR_list)) {
      # If diagonal, set to zero
      if (i == j) mtx_to_plot[i, j] <- 1 
      # Process only one half, the other is symmetric
      if (i > j) {
        mtx_to_plot[i, j] <- mtx_to_plot[j, i] <- jaccard(all_excludeGR_list[[i]], all_excludeGR_list[[j]])[["jaccard"]]
      }
    }
  }
)


##### NUMBER FORMATTING ######

nicer.numbers <- matrix(
  data = 0,
  ncol = ncol(mtx_to_plot),
  nrow = nrow(mtx_to_plot)
)

# we want to view these numbers NOT in scientific notation
nicer.numbers[which(mtx_to_plot==1)] <- '1.00'
nicer.numbers[which(mtx_to_plot==0)] <- '0.00'


# for each jaccard value that isn't 0 or 1...
for (i in which(mtx_to_plot > 0 & mtx_to_plot < 1) ){

  # if corresponding cell in actual matrix is more than 0.01
  ifelse(mtx_to_plot[i] > 0.01,

         # round two decimal places and format normal
         nicer.numbers[i] <- as.character(
           format(
             as.numeric( mtx_to_plot[i] ),
             scientific = F,
             digits = 2
           )
         ),

         # otherwise label as less than 0.01
         nicer.numbers[i] <- as.character('< 0.01')
  )
}

##### PLOTTING #####

# get quantiles of all values, used for creating a nice gradient
vals <- mtx_to_plot[-which(mtx_to_plot==1)]

quants <- quantile(vals, probs = seq(0, 1, 0.1))

# to distinguish lowest value from absolute 0
quants <- append(quants, 0.000000001)
# to distinguish highest values
quants <- append(quants, 0.999999999)
quants <- sort(unique(quants))
quants
# create color gradient
cols.O <- c(
  '#FFFFFF',
  '#FFF7F5',
  '#FFEDE8',
  '#FFBDAB',
  '#FFB19C',
  '#FFA187',
  '#FF9173',
  '#FF8361',
  '#FF7752',
  '#FF6B42',
  '#FF3903',
  '#C72B00'
)

# Trim row/colnames
rownames(mtx_to_plot) <- colnames(mtx_to_plot) <- str_trunc(name_short, width = 25)

# change cell size of heatmap
cell.size = 25
text.size = cell.size/2

# create clusters
cluster.method <- "euclidean"

# plot matrix
jaccard <- pheatmap(

  # data
  data.matrix(mtx_to_plot),

  # clustering options
  clustering_method = "ward.D",
  clustering_distance_rows = cluster.method,
  clustering_distance_cols = cluster.method,

  # number options
  display_numbers = nicer.numbers,
  fontsize_number=cell.size/4,
  number_color = 'black',

  # cell formatting options
  cellwidth = cell.size,
  cellheight = cell.size,
  fontsize = text.size,

  # tree options
  treeheight_row = 0,
  treeheight_col = 15,

  # i.e. how fine is the resolution
  breaks = quants,

  # other
  legend = T,
  color = cols.O,
  angle_col = 45

)

jaccard

# svg(file.path('man', 'figures', 'excluderanges_hg38_jaccard.svg'))
# jaccard
# dev.off()
```

```{r echo=FALSE, eval=F}
knitr::include_graphics('man/figures/excluderanges_hg38_jaccard.svg')
```


Note that some excludable ranges objects contain six columns, implying there may be 
some interesting metadata. Let's explore one.

```{r excluderanges_hg38_Reddy_metadata, fig.width=6.5, fig.height=3}
mcols(excludeGR.hg38.Reddy)
mtx_to_plot <- as.data.frame(table(mcols(excludeGR.hg38.Reddy)[["name"]]))
colnames(mtx_to_plot) <- c("Type", "Number")
mtx_to_plot <- mtx_to_plot[order(mtx_to_plot$Number), ]
mtx_to_plot$Type <- factor(mtx_to_plot$Type, levels = mtx_to_plot$Type)
ggplot(mtx_to_plot, aes(x = Number, y = Type, fill = Type)) +
  geom_bar(stat="identity") +
  theme_bw() + theme(legend.position = "none")
# ggsave("man/figures/excluderanges_hg38_Reddy_metadata.png", width = 5, height = 2.5)
```

```{r echo=FALSE, eval=FALSE}
knitr::include_graphics('man/figures/excluderanges_hg38_Reddy_metadata.png')
```

One may decide to combine the excludable ranges from all labs, although from previous 
results we may decide to follow Anshul's [advice](https://twitter.com/anshulkundaje/status/1263546023151992832?s=20) advice about the [ENCFF356LFX exclusion list regions](https://www.encodeproject.org/files/ENCFF356LFX/) 
and use the `excludeGR.hg38.Kundaje.1` object.

```{r combinedexcluderanges}
excludeGR.hg38.all <- reduce(c(excludeGR.hg38.Bernstein, excludeGR.hg38.Kundaje.1, excludeGR.hg38.Kundaje.2, excludeGR.hg38.Reddy, excludeGR.hg38.Wold, excludeGR.hg38.Yeo))
# Keep only standard chromosomes
excludeGR.hg38.all <- keepStandardChromosomes(excludeGR.hg38.all, pruning.mode = "coarse")
print(length(excludeGR.hg38.all))
summary(width(excludeGR.hg38.all))
```

## Centromeres, telomeres, etc.

Besides the ENCODE-produced excludable regions, we may want to exclude centromeres,
telomeres, and other gap locations. The "Gap Locations" track for Homo Sapiens 
is available for the GRcH37/hg19 genome assembly as a [UCSC 'gap' table](http://genome.ucsc.edu/cgi-bin/hgTables?db=hg19&hgta_group=map&hgta_track=gap&hgta_table=gap&hgta_doSchema=describe+table+schema).
It can be retrieved from `r BiocStyle::Biocpkg("AnnotationHub")`, but lacks 
the metadata columns needed to decide the type of gaps.

```{r eval=FALSE}
# Search for the gap track
# ahData <- query(ah, c("gap", "Homo sapiens", "hg19"))
# ahData[ahData$title == "Gap"]
gaps <- ahData[["AH6444"]]
```


The [UCSC 'gap' table](http://genome.ucsc.edu/cgi-bin/hgTables?db=hg19&hgta_group=map&hgta_track=gap&hgta_table=gap&hgta_doSchema=describe+table+schema) provides better granularity
about the types of gaps available. E.g., for human, hg19, we have the following
types and the number of gaps.

```{r echo=FALSE, out.height="70%", out.width="70%"}
knitr::include_graphics('../man/figures/excluderanges_hg19_gaps_number.png')
```

Those objects are provided as individual GRanges.

Naming convention: `<genome assembly>.UCSC.<gap type>`, e.g.,
`hg19.UCSC.gap_centromere`.

We can similarly load any gap type object.

```{r gapshg19}
query_data <- query(ah, c("excluderanges", "UCSC", "Homo Sapiens", "hg19"))
query_data

gapsGR_hg19_centromere <- query_data[["AH95927"]]
gapsGR_hg19_centromere
```

### Centromeres for the hg38 genome assembly

Note that the UCSC 'gap' table for the hg38 human genome assembly does not contain
genomic coordinates for the "centromere" gap type. These can be obtained from 
the `r BiocStyle::Biocpkg("rCGH")` package as follows:

```{r gapshg38}
suppressPackageStartupMessages(library(rCGH))
suppressPackageStartupMessages(library(GenomicRanges))
# hg38 # data.frame
# Adjust chromosome names
hg38$chrom[hg38$chrom == 23] <- "X"
hg38$chrom[hg38$chrom == 24] <- "Y"
hg38$chrom <- paste0("chr", hg38$chrom)
# Make GRanges object
hg38.UCSC.centromere <- makeGRangesFromDataFrame(hg38, seqnames.field = "chrom", start.field = "centromerStart", end.field = "centromerEnd")
# Assign seqinfo data
seqlengths(hg38.UCSC.centromere) <- hg38$length
genome(hg38.UCSC.centromere)     <- "hg38"
# Resulting object
hg38.UCSC.centromere
```

The `r BiocStyle::Biocpkg("rCGH")` package also contains data for the `hg19` and
`hg18` genomes. The `hg19` centromere data is equivalent to the `hg19.UCSC.centromere` 
object provided in our `r BiocStyle::Biocpkg("excluderanges")` package.

## Source data for the excludable regions

```{r echo=FALSE}
mtx <- read.csv("../inst/extdata/table_excluderanges.csv")
knitr::kable(mtx)
```

```{r echo=FALSE}
mtx <- read.csv("../inst/extdata/table_gap.csv")
knitr::kable(mtx)
```

Download all data from the [Google Drive folder](https://drive.google.com/drive/folders/1MFn6LPZD1zZRQz7biR0Fyl-mzkx4CIxS?usp=sharing)

## `R` session information.

```{r reproduce3, echo=FALSE}
## Session info
sessionInfo()
```

# References
